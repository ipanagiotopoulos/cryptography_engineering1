# CE 1 - Programming assignment 1 problem description

After acquiring my bit material, defining the `PLAINTEXT` and `KEY` constants (along with `MODULO = 26` and `ROUNDS = 16`) and splitting up the bit material into the first 16 and last 8 digits, I created the Mult array the following way:
```python
Mult = [int(first_16[i], 16) + 1 for i in range(len(first_16))]
```
This correctly produced a 16-length array of integers between 1-16.
Then, I created the 4x4 key matrix as follows:
```python
key_nums = [ord(x) - 65 for x in KEY] #convert the key into integers
key_num_matrix = [key_nums[i:i+4] for i in range(0, 16, 4)]
```
And the 8x4 matrix of the last 8 digits of the bit material:
```python
#Defined hex_to_bin(hex) earlier in the code
def hex_to_bin(hex):
    matrix = []
    for char in hex:
        binary = bin(int(char, 16))[2:]
        binary = binary.zfill(4)
        binary_list = [int(bit) for bit in binary]
        matrix.append(binary_list)
    return matrix


last_8_matrix = hex_to_bin(last_8)
```
Then the key schedule matrix using another earlier-defined function:
```python
def matrix_mult_mod_26(matrix1, matrix2):
    if len(matrix1[0]) != len(matrix2):
        raise ValueError("Can't multiply the two matrices.")

    result = [[0] * len(matrix2[0]) for _ in range(len(matrix1))]

    for i in range(len(matrix1)):
        for j in range(len(matrix2[0])):
            for k in range(len(matrix2)):
                result[i][j] += matrix1[i][k] * matrix2[k][j] % MODULO
    return result


key_schedule_matrix = matrix_mult_mod_26(last_8_matrix, key_num_matrix)
```
Also, I initialize a block variable that is just the conversion of `PLAINTEXT` to ints.
```python
block = [ord(x) - 65 for x in PLAINTEXT]
```
And so begins the main loop of each round. I think I should just paste the loop itself and explain the non-self-explanatory parts:

```python
    for r in range(ROUNDS):
        print(f"Input to round {r}:")
        print(ints_to_string(block))
        i = r % 4

        round_key_values = [row[i] for row in key_schedule_matrix]
        print("Roundkey:")
        print(round_key_values)

        left_half = block[0:8]
        right_half = block[8:16]
        block = []

        if r != ROUNDS-1:
            for j in range(len(right_half)):
                block.append(right_half[j])

        new_left_half = [(Mult[r] * right_half[i] +
                          round_key_values[i]) % MODULO for i in range(len(left_half))]

        for j in range(len(new_left_half)):
            block.append(new_left_half[j])

        if r == ROUNDS-1:
            for j in range(len(right_half)):
                block.append(right_half[j])
    print("Result:")
    print(ints_to_string(block))
```

The splitting of the two parts (left and right) seems to work fine when viewing the printed outputs.

According to the description of exercise 4, the Feistel network does **not** switch the two parts on the _last round_, so I had to write a check two times (see `if r != ROUND-1` and `if r == ROUNDS-1` blocks).

The program runs through with seemingly no calculation errors at first glance.
The splitting of the bit material is alright, the intermediate calculations like the matrices, `Mult` array and the `new_left_half` seem to be working correctly.

I feel that something is definitely wrong in the main loop of the program, but I can't figure out what it is.

Thank you for your help!